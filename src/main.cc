
#include<iostream>
#include<iterator>
#include<array>
#include<map>

#include "variable.h"

using std::cout;
using std::endl;

#define DEBUG(x) \
    cout << "DEBUG:" << (#x) << " = " << (x) << endl;

using std::map;

// Testing /////////////////////////////////////////////////////////////////////
#define N 9

typedef map<int, std::size_t> term;
typedef map<term, std::size_t> expr;

void dump_expr(expr e)
{
    bool not_first=false;
    for(auto itr = e.begin(); itr!=e.end(); itr++) {
        bool non_empty = false;
        auto t0 = itr->first;

        if(not_first)
            cout << " ";
        else
            not_first = true;
        
        cout << "["
             << itr->second << ";"
             << t0[0] << ";";

        t0.erase(0);
        for(auto p = t0.begin(); p!=t0.end(); p++ )
        {   if(non_empty)
                cout << ",";
            else
                non_empty=true;
            cout << "(" << p->first << "," << p->second << ")";
        }
        cout << "]";
    }

    cout << endl;
}



int main
() {
    term t0;
    expr expr0, expr1, *p0 = &expr0, *p1 = &expr1, *tmp;

    std::array<expr, N+1> cformula;
    
    t0[0] = 0;
    expr0[t0] = 1;
    for( auto ii = 0; ii <= N; ii++ )
    {
        auto it = p0->begin();
        for(; it != p0->end(); it++)
        {   auto coeff = it->second;
            auto t1 = it->first;
            
            // construct term generated by replacing f^(k)[g[x]] with
            //  it's derivative: f^(k+1)[g[x]] * g^(1)[x]
            t1[0]++;  t1[1]++;

            // add contribution to new expression
            (*p1)[t1] += coeff;

            // reset t1
            t1[0]--;
            if((it->first).count(1) > 0)
                t1[1]--;
            else
                t1.erase(1);

            // handle remaining factors of term
            auto ftr = (it->first).lower_bound(1);
            for(; ftr != (it->first).end(); ftr++)
            {   auto n = ftr->first;     // order of derivative
                auto expo = ftr->second; // factor exponent 

                // construct term generated by replacing (D[g[x], {x, n}])^expo
                //  with it's derivative
                t1[n+1]++;
                if(expo > 1)
                    t1[n]=expo-1;
                else
                    t1.erase(n);

                // add contribution to new expression
                (*p1)[t1] += (expo)*(coeff);

                // reset t1 to initial state
                t1[n] = expo;
                if((it->first).count(n+1) > 0)
                    t1[n+1]--;
                else
                    t1.erase(n+1);
                
            }
        }

        cformula[ii] = *p0;
        
        // swap pointers
        tmp = p1; p1 = p0; p0 = tmp;
        p1->clear();

    }

    diff::variable<N>::state_vec v1, v2;
    for(auto ii =0; ii<=N; ii++)
    {
        
        dump_expr(cformula[ii]);
    }
}


 /*

  [1;0;]
  [1;1;(1,1)]
  [1;2;(1,2)]+[1;1;(2,1)]
  
  [1;3;(1,3)]+[2;2;(1,1),(2,1)]
             +[1;2;(1,1),(2,1)]+[1;1;(3,1)]
  ---------------------------------------------------------------
 =[1;3;(1,3)]+[3;2;(1,1),(2,1)]+[1;1;(3,1)]
  
  [1;4;(1,4)]+[3;3;(1,2),(2,1)]
             +[3;3;(1,2),(2,1)]+[3;2;(2,2)]+[3;2;(1,1),(3,1)]
                                           +[1;2;(1,1),(3,1)]+[1;1;(4,1)]
  ---------------------------------------------------------------
 =[1;4;(1,4)]+[6;3;(1,2),(2,1)]+[3;2;(2,2)]+[4;2;(1,1),(3,1)]+[1;1;(4,1)]

 
  [1;5;(1,5)]+[ 4;4;(1,3),(2,1)]
             +[ 6;4;(1,3),(2,1)]+[12;3;(1,1),(2,2)]+[ 6;3;(1,2),(3,1)]
                                +[ 3;3;(1,1),(2,2)]                   +[ 6;2;(2,1),(3,1)]
                                                   +[ 4;3;(1,2),(3,1)]+[ 4;2;(2,1),(3,1)]+[4;2;(1,1),(4,1)]
                                                                                         +[1;2;(1,1),(4,1)]+[1;1;(5,1)]
  ---------------------------------------------------------------
 =[1;5;(1,5)]+[10;4;(1,3),(2,1)]+[15;3;(1,1),(2,2)]+[10;3;(1,2),(3,1)]+[10;2;(2,1),(3,1)]+[5;2;(1,1),(4,1)]+[1;1;(5,1)]



  map< int, map< array<int, N>, int >
    */
