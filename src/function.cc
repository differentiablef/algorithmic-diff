#include "function.h"


namespace diff {
namespace function {
// real location for `comp_formula` 
std::map<int, cps_expr> comp_formula;

// initialize function usage by pre-computing general formula for composition
void init(std::size_t N)
{
    term t0;
    ps_expr expr0, expr1, *p0 = &expr0, *p1 = &expr1, *tmp;
    
    t0[0] = 0;
    expr0[t0] = 1;
    for( auto ii = 0; ii <= N; ii++ )
    {
        auto it = p0->begin();
        for(; it != p0->end(); it++)
        {   auto coeff = it->second;
            auto t1 = it->first;
            
            // construct term generated by replacing f^(k)[g[x]] with
            //  it's derivative: f^(k+1)[g[x]] * g^(1)[x]
            t1[0]++;  t1[1]++;
            

            // add contribution to new expression
            (*p1)[t1] += coeff;

            // reset t1
            t1[0]--;
            if((it->first).count(1) > 0)
                t1[1]--;
            else
                t1.erase(1);

            // handle remaining factors of term
            auto ftr = (it->first).lower_bound(1);
            for(; ftr != (it->first).end(); ftr++)
            {   auto n = ftr->first;     // order of derivative
                auto expo = ftr->second; // factor exponent 

                // construct term generated by replacing (D[g[x], {x, n}])^expo
                //  with it's derivative
                t1[n+1]++;
                if(expo > 1)
                    t1[n]=expo-1;
                else
                    t1.erase(n);

                // add contribution to new expression
                (*p1)[t1] += (expo)*(coeff);

                // reset t1 to initial state
                t1[n] = expo;
                if((it->first).count(n+1) > 0)
                    t1[n+1]--;
                else
                    t1.erase(n+1);
                
            }
        }
        // XXX: this is a hack job fixup for rounding issues
        cps_expr ctmp;
        for(auto t = p0->begin(); t != p0->end(); t++){
            auto t0 = t->first;
            auto itr = t0.begin();
            auto idx = itr->second;
            t0.erase(itr);
            ctmp[idx][t0] += t->second;
        }    

        comp_formula[ii] = ctmp;
        
        // swap pointers
        tmp = p1; p1 = p0; p0 = tmp;
        p1->clear();

    }

}


} // function
} // diff
